/**
 * Babylon Question Manager
 * 
 * @module engine/QuestionManager
 * 
 * @description
 * Manages the complete lifecycle of prediction market questions in the Babylon game.
 * Questions are the core mechanic that drives events, NPC behavior, and player betting.
 * 
 * **Core Responsibilities:**
 * - Generate new questions daily (1-3 per day) based on scenarios and recent events
 * - Track active questions (max 20 concurrent)
 * - Resolve questions when resolution date is reached (24h-7d from creation)
 * - Generate resolution events that definitively prove outcomes
 * - Ensure game events are aligned with active questions
 * 
 * **Question Lifecycle:**
 * 1. **Creation** - Generated by LLM with resolutionDate 24h-7d in future
 * 2. **Active** - Appears in markets, events generated around it, tradable
 * 3. **Resolved** - Outcome determined, positions settled, no longer tradable
 * 4. **Cancelled** - Removed without resolution (rare, edge cases only)
 * 
 * **Generation Strategy:**
 * - Uses LLM to create contextually relevant questions
 * - Considers recent events and current storylines
 * - Avoids duplicate or overlapping questions
 * - Ensures questions align with available actors and organizations
 * 
 * **Resolution Timing:**
 * - Questions resolve 1-7 days after creation
 * - Longer timespans for complex questions (mergers, investigations)
 * - Shorter timespans for urgent developments (announcements, scandals)
 * - Resolution event generated to prove outcome definitively
 * 
 * @see {@link GameEngine} - Uses QuestionManager to generate daily questions
 * @see {@link FeedGenerator} - Creates posts and discussions about active questions
 * 
 * @example
 * ```typescript
 * const qm = new QuestionManager(llmClient);
 * 
 * // Generate new questions
 * const questions = await qm.generateDailyQuestions({
 *   currentDate: '2025-10-15',
 *   scenarios,
 *   actors,
 *   organizations,
 *   activeQuestions: [],
 *   recentEvents: [],
 *   nextQuestionId: 1
 * });
 * 
 * // Check for questions to resolve
 * const toResolve = qm.getQuestionsToResolve(activeQuestions, '2025-10-16');
 * 
 * // Resolve a question
 * const resolved = qm.resolveQuestion(question, true); // true = YES outcome
 * ```
 */

import type { Question, Scenario, SelectedActor, Organization, DayTimeline } from '@/shared/types';
import type { BabylonLLMClient } from '../generator/llm/openai-client';
import { questionGeneration, questionResolutionValidation, renderPrompt } from '@/prompts';
import { logger } from '@/lib/logger';
import { shuffleArray } from '@/lib/utils/randomization';

/**
 * Parameters for question generation
 * 
 * @interface QuestionCreationParams
 * 
 * @property currentDate - ISO date string (YYYY-MM-DD) for the generation date
 * @property scenarios - Available game scenarios for context
 * @property actors - Available actors (filtered to main/supporting roles)
 * @property organizations - Available organizations (companies, media, etc.)
 * @property activeQuestions - Currently active questions (to avoid duplicates)
 * @property recentEvents - Recent game history for context
 * @property nextQuestionId - Next available numeric ID for new questions
 */
export interface QuestionCreationParams {
  currentDate: string;
  scenarios: Scenario[];
  actors: SelectedActor[];
  organizations: Organization[];
  activeQuestions: Question[];
  recentEvents: DayTimeline[];
  nextQuestionId: number;
}

/**
 * Question Manager - Handles question lifecycle
 * 
 * @class QuestionManager
 * 
 * @description
 * Central manager for all prediction market questions. Uses LLM to generate
 * contextually relevant questions and manages their lifecycle from creation
 * through resolution.
 * 
 * **Key Methods:**
 * - `generateDailyQuestions()` - Create 1-3 new questions per day
 * - `getQuestionsToResolve()` - Find questions ready to resolve
 * - `resolveQuestion()` - Mark question as resolved with final outcome
 * - `generateResolutionEvent()` - Create definitive proof of outcome
 * 
 * @usage
 * Instantiated once by GameEngine and used throughout the game lifecycle.
 */
export class QuestionManager {
  private llm: BabylonLLMClient;

  /**
   * Create a new QuestionManager instance
   * 
   * @param llm - Babylon LLM client for question generation
   */
  constructor(llm: BabylonLLMClient) {
    this.llm = llm;
  }

  /**
   * Generate new questions for the current day
   * 
   * @param params - Question creation parameters including context and IDs
   * @returns Array of newly generated questions (1-3 questions, empty if at capacity)
   * 
   * @description
   * Uses LLM to generate contextually relevant prediction market questions based on
   * recent events, active scenarios, and available actors. Questions are designed
   * to drive interesting events and player engagement.
   * 
   * **Generation Logic:**
   * - Generates 1-3 questions per call (random)
   * - Respects 20 question maximum (returns empty array if at capacity)
   * - Uses recent events for contextual continuity
   * - Avoids duplicating active questions
   * - Shuffles actors/orgs for variety
   * 
   * **Resolution Timing:**
   * - LLM determines `daysUntilResolution` (1-7 days)
   * - Resolution date calculated from currentDate
   * - Clamped to valid range (1-7 days)
   * 
   * **Question Properties:**
   * - `id`: Numeric ID starting from `nextQuestionId`
   * - `text`: LLM-generated question text
   * - `scenario`: Scenario ID this question relates to
   * - `outcome`: Predetermined outcome (true = YES, false = NO)
   * - `status`: Always 'active' for new questions
   * - `createdDate`: Current date
   * - `resolutionDate`: 1-7 days in the future
   * 
   * @throws Never throws - returns empty array on error
   * 
   * @example
   * ```typescript
   * const questions = await qm.generateDailyQuestions({
   *   currentDate: '2025-10-15',
   *   scenarios: gameScenarios,
   *   actors: mainActors,
   *   organizations: companies,
   *   activeQuestions: [...existingQuestions],
   *   recentEvents: [...recentDays],
   *   nextQuestionId: 42
   * });
   * // => [
   * //   { id: 42, text: "Will TechCorp announce...", outcome: true, ... },
   * //   { id: 43, text: "Will the scandal force...", outcome: false, ... }
   * // ]
   * ```
   */
  async generateDailyQuestions(params: QuestionCreationParams): Promise<Question[]> {
    const {
      currentDate,
      scenarios,
      actors,
      organizations,
      activeQuestions,
      recentEvents,
      nextQuestionId,
    } = params;

    // Don't generate if we're at max capacity (20 questions)
    if (activeQuestions.length >= 20) {
      logger.warn('Max 20 questions reached, skipping generation', undefined, 'QuestionManager');
      return [];
    }

    // Generate 1-3 new questions
    const numToGenerate = Math.min(
      Math.floor(Math.random() * 3) + 1, // 1-3 questions
      20 - activeQuestions.length // Don't exceed max
    );

    const currentDateObj = new Date(currentDate);

    // Build context from recent events
    const recentContext = recentEvents.length > 0
      ? `\n\nRECENT EVENTS (Last ${recentEvents.length} days):\n${recentEvents
          .slice(-5)
          .map(day => `Day ${day.day}: ${day.events.map(e => e.description).join('; ')}`)
          .join('\n')}`
      : '';

    // Build context from active questions
    const activeQuestionsContext = activeQuestions.length > 0
      ? `\n\nCURRENT ACTIVE QUESTIONS (${activeQuestions.length}/20):\n${activeQuestions
          .map(q => `- ${q.text} (resolves ${q.resolutionDate})`)
          .join('\n')}`
      : '\n\nNo active questions yet.';

    const prompt = this.buildQuestionGenerationPrompt(
      scenarios,
      actors,
      organizations,
      recentContext,
      activeQuestionsContext,
      numToGenerate
    );

    const rawResponse = await this.llm.generateJSON<{
      questions: Array<{
        text: string;
        scenario: number;
        daysUntilResolution: number; // 1-7 days
        expectedOutcome: boolean;
      }>;
    } | {
      response: {
        questions: Array<{
          text: string;
          scenario: number;
          daysUntilResolution: number; // 1-7 days
          expectedOutcome: boolean;
        }>;
      }
    }>(prompt, undefined, {
      temperature: 0.9,
      maxTokens: 8000,
    });

    // Handle XML structure
    const response = 'response' in rawResponse && rawResponse.response
      ? rawResponse.response
      : rawResponse as { questions: Array<{ text: string; scenario: number; daysUntilResolution: number; expectedOutcome: boolean }> };

    if (!response.questions || response.questions.length === 0) {
      logger.warn('LLM returned no questions', undefined, 'QuestionManager');
      return [];
    }

    // Convert to Question objects with dates and IDs
    const questions: Question[] = response.questions.slice(0, numToGenerate).map((q, index) => {
      const resolutionDate = new Date(currentDateObj);
      resolutionDate.setDate(
        resolutionDate.getDate() + Math.max(1, Math.min(7, q.daysUntilResolution || 3))
      );

      return {
        id: nextQuestionId + index,
        text: q.text,
        scenario: q.scenario || 1,
        outcome: q.expectedOutcome,
        rank: 1,
        createdDate: currentDate,
        resolutionDate: resolutionDate.toISOString().split('T')[0]!,
        status: 'active',
      };
    });

    return questions;
  }

  /**
   * Build LLM prompt for question generation
   */
  private buildQuestionGenerationPrompt(
    scenarios: Scenario[],
    actors: SelectedActor[],
    organizations: Organization[],
    recentContext: string,
    activeQuestionsContext: string,
    numToGenerate: number
  ): string {
    const scenariosList = scenarios
      .map(
        s => `
Scenario ${s.id}: ${s.title}
${s.description}
Actors: ${s.mainActors.join(', ')}
${s.involvedOrganizations?.length ? `Organizations: ${s.involvedOrganizations.join(', ')}` : ''}
`
      )
      .join('\n');

    // Shuffle actors and organizations to add variety to prompts
    const shuffledActors = shuffleArray(
      actors.filter(a => a.role === 'main' || a.role === 'supporting')
    );
    const actorsList = shuffledActors
      .slice(0, 20)
      .map(a => `- ${a.name}: ${a.description}`)
      .join('\n');

    const shuffledOrgs = shuffleArray(
      organizations.filter(o => o.type === 'company')
    );
    const orgsList = shuffledOrgs
      .slice(0, 15)
      .map(o => `- ${o.name}: ${o.description}`)
      .join('\n');

    return renderPrompt(questionGeneration, {
      scenariosList,
      actorsList,
      orgsList,
      recentContext,
      activeQuestionsContext,
      numToGenerate: numToGenerate.toString()
    });
  }

  /**
   * Get questions that should be resolved today
   * 
   * @param activeQuestions - Array of currently active questions
   * @param currentDate - Current date as ISO string (YYYY-MM-DD)
   * @returns Array of questions ready for resolution
   * 
   * @description
   * Filters active questions to find those whose resolution date has been reached.
   * These questions should be resolved in the current game tick.
   * 
   * **Resolution Criteria:**
   * - Question must have a `resolutionDate` set
   * - Resolution date must be <= current date
   * - Only checks active questions (not already resolved)
   * 
   * **Typical Flow:**
   * 1. GameEngine calls this during tick
   * 2. For each returned question:
   *    - Generate resolution event
   *    - Call `resolveQuestion()`
   *    - Settle all positions
   *    - Update reputation
   * 
   * @usage
   * Called by GameEngine every tick to check for questions ready to resolve.
   * 
   * @example
   * ```typescript
   * const toResolve = qm.getQuestionsToResolve(activeQuestions, '2025-10-20');
   * // => [Question { id: 5, resolutionDate: '2025-10-19', ... }]
   * 
   * for (const question of toResolve) {
   *   // Generate resolution event
   *   // Resolve question
   *   // Settle positions
   * }
   * ```
   */
  getQuestionsToResolve(activeQuestions: Question[], currentDate: string): Question[] {
    const currentDateObj = new Date(currentDate);

    return activeQuestions.filter(q => {
      if (!q.resolutionDate) return false;
      const resolutionDateObj = new Date(q.resolutionDate);
      return resolutionDateObj <= currentDateObj;
    });
  }

  /**
   * Resolve a question with final outcome
   * 
   * @param question - Question to resolve
   * @param outcome - Final outcome (true = YES, false = NO)
   * @returns Resolved question with updated status and outcome
   * 
   * @description
   * Marks a question as resolved and records the final outcome. This is a pure
   * function that returns a new question object - it does not mutate the input.
   * 
   * **What This Does:**
   * - Sets `status` to 'resolved'
   * - Sets `resolvedOutcome` to the provided outcome
   * - Preserves all other question properties
   * 
   * **What This Does NOT Do:**
   * - Does not settle positions (handled by GameEngine)
   * - Does not update reputation (handled by ReputationService)
   * - Does not persist to database (handled by GameEngine)
   * - Does not generate events (handled by GameEngine)
   * 
   * @usage
   * Called by GameEngine after generating a resolution event.
   * 
   * @example
   * ```typescript
   * const question = { id: 5, text: "Will...", outcome: true, status: 'active', ... };
   * const resolved = qm.resolveQuestion(question, true);
   * // => { ...question, status: 'resolved', resolvedOutcome: true }
   * ```
   */
  resolveQuestion(question: Question, outcome: boolean): Question {
    return {
      ...question,
      status: 'resolved',
      resolvedOutcome: outcome,
    };
  }

  /**
   * Generate a resolution event that proves the question outcome
   * 
   * @param question - Question being resolved
   * @param _actors - Available actors (currently unused, kept for interface compatibility)
   * @param _organizations - Available organizations (currently unused, kept for interface compatibility)
   * @param recentEvents - Recent game timeline for context
   * @returns Event description string that definitively proves the outcome
   * 
   * @description
   * Uses LLM to generate a dramatic, definitive event that proves whether the
   * question outcome is YES or NO. This event provides closure to the narrative
   * and justifies position settlements.
   * 
   * **Event Requirements:**
   * - Must be concrete and observable
   * - Must DEFINITIVELY prove the outcome
   * - Should reference recent related events for continuity
   * - Should be dramatic and satisfying for players
   * 
   * **LLM Prompting:**
   * - Uses recent related events as context
   * - Instructs LLM to prove specific outcome (YES/NO)
   * - Temperature 0.7 for consistent but varied events
   * - Falls back to template if LLM fails
   * 
   * @usage
   * Called by GameEngine when resolving questions.
   * 
   * @example
   * ```typescript
   * const event = await qm.generateResolutionEvent(
   *   question,
   *   actors,
   *   organizations,
   *   recentTimeline
   * );
   * // => "TechCorp officially announces merger completion, signing ceremony held today"
   * ```
   */
  async generateResolutionEvent(
    question: Question,
    _actors: SelectedActor[],
    _organizations: Organization[],
    recentEvents: DayTimeline[]
  ): Promise<string> {
    // Get context from recent events related to this question
    const relatedEvents = recentEvents
      .flatMap(day => day.events)
      .filter(e => e.relatedQuestion === question.id)
      .slice(-3);

    const eventHistory =
      relatedEvents.length > 0
        ? `Recent events: ${relatedEvents.map(e => e.description).join('; ')}`
        : 'No prior events';

    const outcomeContext = question.outcome 
      ? 'PROVES it happened/succeeded' 
      : 'PROVES it failed/was cancelled/did not happen';

    const prompt = renderPrompt(questionResolutionValidation, {
      questionText: question.text,
      outcome: question.outcome ? 'YES' : 'NO',
      eventHistory,
      contextInfo: '',
      outcomeContext
    });

    const rawResponse = await this.llm.generateJSON<{ event: string; type: string } | { response: { event: string; type: string } }>(
      prompt,
      undefined,
      { temperature: 0.7, maxTokens: 5000 }
    );

    // Handle XML structure
    const response = 'response' in rawResponse && rawResponse.response
      ? rawResponse.response
      : rawResponse as { event: string; type: string };

    return response.event || `Resolution: ${question.text} outcome is ${question.outcome ? 'YES' : 'NO'}`;
  }

  /**
   * Get all active questions from a question array
   * 
   * @param questions - Array of questions to filter
   * @returns Array of questions with status='active'
   * 
   * @description
   * Simple filter utility to extract active questions. Active questions are
   * those that are currently tradable and generating events.
   * 
   * @usage
   * Used by GameEngine to get questions for event generation.
   * 
   * @example
   * ```typescript
   * const active = qm.getActiveQuestions(allQuestions);
   * // => [Question { status: 'active', ... }, Question { status: 'active', ... }]
   * ```
   */
  getActiveQuestions(questions: Question[]): Question[] {
    return questions.filter(q => q.status === 'active');
  }

  /**
   * Get all resolved questions from a question array
   * 
   * @param questions - Array of questions to filter
   * @returns Array of questions with status='resolved'
   * 
   * @description
   * Simple filter utility to extract resolved questions. Useful for analytics,
   * displaying history, and calculating statistics.
   * 
   * @usage
   * Used for displaying question history and analytics.
   * 
   * @example
   * ```typescript
   * const resolved = qm.getResolvedQuestions(allQuestions);
   * // => [Question { status: 'resolved', resolvedOutcome: true, ... }]
   * ```
   */
  getResolvedQuestions(questions: Question[]): Question[] {
    return questions.filter(q => q.status === 'resolved');
  }

  /**
   * Calculate days remaining until question resolves
   * 
   * @param question - Question to check
   * @param currentDate - Current date as ISO string (YYYY-MM-DD)
   * @returns Number of days until resolution (0 if today/past, 999 if no resolution date)
   * 
   * @description
   * Calculates the number of days from currentDate until the question's
   * resolutionDate. Used for urgency calculations and UI display.
   * 
   * **Return Values:**
   * - `0`: Resolves today or already past
   * - `1-7`: Days remaining (normal range)
   * - `999`: No resolution date set (shouldn't happen)
   * 
   * **Rounding:**
   * - Uses `Math.ceil()` to round up partial days
   * - Uses `Math.max(0)` to prevent negative values
   * 
   * @usage
   * Used by FeedGenerator to adjust clue strength (closer = stronger clues).
   * 
   * @example
   * ```typescript
   * const days = qm.getDaysUntilResolution(question, '2025-10-15');
   * // If resolutionDate is '2025-10-18':
   * // => 3
   * 
   * const days = qm.getDaysUntilResolution(question, '2025-10-18');
   * // If resolutionDate is '2025-10-18':
   * // => 0 (resolves today)
   * ```
   */
  getDaysUntilResolution(question: Question, currentDate: string): number {
    if (!question.resolutionDate) return 999;

    const current = new Date(currentDate);
    const resolution = new Date(question.resolutionDate);
    const diffTime = resolution.getTime() - current.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    return Math.max(0, diffDays);
  }
}



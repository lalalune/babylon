/**
 * Synpress E2E Test: Waitlist & Viral Loop System
 * 
 * Tests the complete waitlist flow including:
 * - Signup and onboarding
 * - Dynamic leaderboard ranking
 * - Referral code system
 * - Points attribution
 * - Fraud prevention
 * - Top inviters leaderboard
 */

import { testWithSynpress } from '@synthetixio/synpress'
import { MetaMask, metaMaskFixtures } from '@synthetixio/synpress/playwright'
import { expect } from '@playwright/test'
import type { Page } from '@playwright/test'

const test = testWithSynpress(metaMaskFixtures({}))

const { describe, beforeEach } = test

// Test configuration
const BASE_URL = process.env.BASE_URL || 'http://localhost:3000'
const WAITLIST_URL = `${BASE_URL}/?comingsoon=true`

describe('Waitlist System - Complete E2E Flow', () => {
  let user1InviteCode: string
  let user1InitialRank: number

  describe('Waitlist Signup Flow', () => {
    test('should display coming soon page with join waitlist button', async ({ page }) => {
      await page.goto(WAITLIST_URL)

      // Verify page loads
      await expect(page).toHaveURL(new RegExp('comingsoon=true'))

      // Check for coming soon elements
      await expect(page.locator('text=Babylon')).toBeVisible()
      await expect(page.locator('text=Join Waitlist')).toBeVisible()
      
      // Verify features are displayed
      await expect(page.locator('text=Prediction Markets')).toBeVisible()
      await expect(page.locator('text=AI Agents')).toBeVisible()
      await expect(page.locator('text=Gamified Trading')).toBeVisible()
    })

    test('should trigger Privy login when clicking Join Waitlist', async ({ page }) => {
      await page.goto(WAITLIST_URL)

      // Click join waitlist button
      await page.click('text=Join Waitlist')

      // Wait for Privy modal to appear
      await page.waitForSelector('[data-privy-modal]', { timeout: 10000 })
      
      // Verify login options are available
      const privyModal = page.locator('[data-privy-modal]')
      await expect(privyModal).toBeVisible()
    })

    test('should complete waitlist signup with wallet', async ({ context, page, metamask }: {
      context: any
      page: Page
      metamask: MetaMask
    }) => {
      await page.goto(WAITLIST_URL)

      // Click join waitlist
      await page.click('text=Join Waitlist')

      // Wait for Privy modal
      await page.waitForSelector('[data-privy-modal]', { timeout: 10000 })

      // Select wallet login
      const walletButton = page.locator('button:has-text("Wallet")').first()
      await walletButton.click()

      // Connect MetaMask
      await metamask.connectToDapp()

      // Sign message if required
      try {
        await metamask.confirmSignature()
      } catch {
        // Signature might not be required
      }

      // Wait for onboarding to complete or coming soon to show waitlist
      await page.waitForTimeout(5000)

      // Should show either onboarding modal or waitlist position
      const hasOnboarding = await page.locator('text=Username').isVisible().catch(() => false)
      const hasWaitlist = await page.locator('text=Your Waitlist Position').isVisible().catch(() => false)

      expect(hasOnboarding || hasWaitlist).toBe(true)
    })
  })

  describe('Dynamic Leaderboard Ranking', () => {
    test('should display dynamic position based on invite points', async ({ page }) => {
      // This test requires pre-seeded users with different invite points
      await page.goto(`${BASE_URL}/api/waitlist/position?userId=test-user-id`)

      const response = await page.waitForResponse(res => 
        res.url().includes('/api/waitlist/position') && res.status() === 200
      )

      const data = await response.json()

      // Verify response structure
      expect(data).toHaveProperty('leaderboardRank')
      expect(data).toHaveProperty('totalAhead')
      expect(data).toHaveProperty('percentile')
      expect(data).toHaveProperty('inviteCode')
      expect(data).toHaveProperty('pointsBreakdown')
      expect(data.pointsBreakdown).toHaveProperty('invite')
      expect(data.pointsBreakdown).toHaveProperty('earned')
      expect(data.pointsBreakdown).toHaveProperty('bonus')
    })

    test('should show correct position on Coming Soon page', async ({ page }) => {
      await page.goto(WAITLIST_URL)

      // Assuming user is logged in from previous test
      // Look for position display
      const positionElement = page.locator('text=/Your Position in Line/i')
      
      if (await positionElement.isVisible({ timeout: 5000 }).catch(() => false)) {
        // Verify position number is displayed
        const rankElement = page.locator('text=/#\\d+/')
        await expect(rankElement.first()).toBeVisible()

        // Verify percentile is shown
        await expect(page.locator('text=/Top \\d+%/')).toBeVisible()
      }
    })
  })

  describe('Referral Code System', () => {
    test('should display invite code to authenticated users', async ({ page }) => {
      await page.goto(WAITLIST_URL)

      // Wait for waitlist data to load (if user is authenticated)
      await page.waitForTimeout(3000)

      const hasInviteCode = await page.locator('text=/\\?ref=/').isVisible().catch(() => false)
      
      if (hasInviteCode) {
        // Verify copy button exists
        await expect(page.locator('button:has-text("Copy")')).toBeVisible()

        // Extract invite code for later use
        const inviteCodeText = await page.locator('text=/\\?ref=\\w+/').textContent()
        const match = inviteCodeText?.match(/\\?ref=(\\w+)/)
        if (match) {
          user1InviteCode = match[1]
          console.log(`Extracted invite code: ${user1InviteCode}`)
        }
      }
    })

    test('should copy invite URL to clipboard', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      const copyButton = page.locator('button:has-text("Copy")')
      
      if (await copyButton.isVisible().catch(() => false)) {
        // Click copy button
        await copyButton.click()

        // Verify button text changes to "Copied!"
        await expect(page.locator('button:has-text("Copied!")')).toBeVisible({ timeout: 2000 })
      }
    })

    test('should accept referral code from URL', async ({ page }) => {
      if (!user1InviteCode) {
        test.skip()
        return
      }

      // Visit with referral code
      await page.goto(`${WAITLIST_URL}&ref=${user1InviteCode}`)

      // Verify URL contains referral code
      expect(page.url()).toContain(`ref=${user1InviteCode}`)

      // The referral should be captured by ReferralCaptureProvider
      // and used during signup
    })
  })

  describe('Points and Bonuses', () => {
    test('should show points breakdown', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      // Look for points breakdown
      const hasPointsBreakdown = await page.locator('text=Invite Points').isVisible().catch(() => false)
      
      if (hasPointsBreakdown) {
        await expect(page.locator('text=Invite Points')).toBeVisible()
        await expect(page.locator('text=Earned Points')).toBeVisible()
        await expect(page.locator('text=Bonus Points')).toBeVisible()
      }
    })

    test('should offer email bonus if not completed', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      const emailBonusButton = page.locator('button:has-text("Add Email Address")')
      
      if (await emailBonusButton.isVisible().catch(() => false)) {
        // Verify bonus amount is shown
        await expect(page.locator('text=+25 points')).toBeVisible()
      }
    })

    test('should offer wallet bonus if not completed', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      const walletBonusButton = page.locator('button:has-text("Connect Wallet")')
      
      if (await walletBonusButton.isVisible().catch(() => false)) {
        // Verify bonus amount is shown
        await expect(page.locator('text=+25 points')).toBeVisible()
      }
    })
  })

  describe('Top Inviters Leaderboard', () => {
    test('should display top inviters leaderboard', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      const leaderboardTitle = page.locator('text=Top Inviters')
      
      if (await leaderboardTitle.isVisible().catch(() => false)) {
        // Verify leaderboard is displayed
        await expect(leaderboardTitle).toBeVisible()

        // Look for rank numbers
        const rankElements = page.locator('text=/#\\d+/')
        const count = await rankElements.count()
        
        // Should show at least one user (self)
        expect(count).toBeGreaterThanOrEqual(1)
      }
    })

    test('should highlight current user in leaderboard', async ({ page }) => {
      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      // Look for "YOU" badge
      const youBadge = page.locator('text=YOU')
      
      if (await youBadge.isVisible().catch(() => false)) {
        // Verify user is highlighted
        await expect(youBadge).toBeVisible()
      }
    })
  })

  describe('Fraud Prevention', () => {
    test('API should reject self-referral attempts', async ({ request }) => {
      // Create a test user
      const createResponse = await request.post(`${BASE_URL}/api/users/signup`, {
        data: {
          username: 'testreferral1',
          displayName: 'Test Referral 1',
          isWaitlist: true,
        },
        headers: {
          'Content-Type': 'application/json',
        },
      })

      if (!createResponse.ok()) {
        // User might already exist or auth might be required
        test.skip()
        return
      }

      const userData = await createResponse.json()
      const userId = userData.user?.id
      const referralCode = userData.user?.referralCode

      if (!userId || !referralCode) {
        test.skip()
        return
      }

      // Try to use own referral code
      const referralResponse = await request.post(`${BASE_URL}/api/waitlist/mark`, {
        data: {
          userId,
          referralCode, // Using own code
        },
        headers: {
          'Content-Type': 'application/json',
        },
      })

      // Should succeed but not award points (self-referral blocked)
      expect(referralResponse.ok()).toBe(true)

      // Verify no points were awarded for self-referral
      const positionResponse = await request.get(`${BASE_URL}/api/waitlist/position?userId=${userId}`)
      const position = await positionResponse.json()

      // Should not have invite points from self-referral
      expect(position.pointsBreakdown.invite).toBe(0)
    })
  })

  describe('Integration with Leaderboard', () => {
    test('main leaderboard should show points breakdown', async ({ page }) => {
      await page.goto(`${BASE_URL}/leaderboard`)
      await page.waitForTimeout(2000)

      // Look for points breakdown
      const hasInvitePoints = await page.locator('text=Invite:').isVisible().catch(() => false)
      const hasEarnedPoints = await page.locator('text=Earned:').isVisible().catch(() => false)
      const hasBonusPoints = await page.locator('text=Bonus:').isVisible().catch(() => false)

      // At least one user should have points breakdown visible
      expect(hasInvitePoints || hasEarnedPoints || hasBonusPoints).toBe(true)
    })

    test('should display All Points instead of Total Points', async ({ page }) => {
      await page.goto(`${BASE_URL}/leaderboard`)
      await page.waitForTimeout(2000)

      // Verify "All Points" is used
      await expect(page.locator('text=All Points')).toBeVisible()

      // Verify "Total Points" is NOT used (old name)
      const hasTotalPoints = await page.locator('text=Total Points').isVisible().catch(() => false)
      expect(hasTotalPoints).toBe(false)
    })
  })

  describe('Rank Movement Celebration', () => {
    test('should show celebration when rank improves', async ({ page }) => {
      // This test requires simulating a rank improvement
      // In a real test, you would:
      // 1. Sign up user
      // 2. Get initial rank
      // 3. Have another user sign up with their code
      // 4. Refresh page
      // 5. Verify celebration shows

      await page.goto(WAITLIST_URL)
      await page.waitForTimeout(2000)

      // Look for celebration element (if rank improved recently)
      const celebration = page.locator('text=You Moved Up!')
      
      // This might not be visible if rank hasn't changed
      // Just verify the element can be rendered
      const exists = await page.locator('text=/You moved/i').count() >= 0
      expect(exists).toBe(true)
    })
  })
})

describe('Waitlist API Endpoints', () => {
  test('POST /api/waitlist/mark should create waitlist entry', async ({ request }) => {
    // Note: This requires authentication token
    // In real test, you would authenticate first

    const response = await request.post(`${BASE_URL}/api/waitlist/mark`, {
      data: {
        userId: 'test-user-id',
        referralCode: 'TESTCODE',
      },
      headers: {
        'Content-Type': 'application/json',
      },
    })

    // Will fail without auth, but validates endpoint exists
    expect([200, 401, 403]).toContain(response.status())
  })

  test('GET /api/waitlist/position should return position data', async ({ request }) => {
    const response = await request.get(`${BASE_URL}/api/waitlist/position?userId=test-user-id`)

    // Will fail if user doesn't exist, but validates endpoint structure
    expect([200, 404, 401]).toContain(response.status())

    if (response.ok()) {
      const data = await response.json()
      expect(data).toHaveProperty('position')
      expect(data).toHaveProperty('leaderboardRank')
      expect(data).toHaveProperty('inviteCode')
      expect(data).toHaveProperty('pointsBreakdown')
    }
  })

  test('GET /api/waitlist/leaderboard should return top users', async ({ request }) => {
    const response = await request.get(`${BASE_URL}/api/waitlist/leaderboard?limit=10`)

    expect(response.ok()).toBe(true)

    const data = await response.json()
    expect(data).toHaveProperty('leaderboard')
    expect(Array.isArray(data.leaderboard)).toBe(true)
  })

  test('POST /api/waitlist/bonus/email should award email bonus', async ({ request }) => {
    const response = await request.post(`${BASE_URL}/api/waitlist/bonus/email`, {
      data: {
        userId: 'test-user-id',
        email: 'test@example.com',
      },
      headers: {
        'Content-Type': 'application/json',
      },
    })

    // Will fail without auth or if user doesn't exist
    expect([200, 401, 404]).toContain(response.status())
  })

  test('POST /api/waitlist/bonus/wallet should award wallet bonus', async ({ request }) => {
    const response = await request.post(`${BASE_URL}/api/waitlist/bonus/wallet`, {
      data: {
        userId: 'test-user-id',
        walletAddress: '0x1234567890123456789012345678901234567890',
      },
      headers: {
        'Content-Type': 'application/json',
      },
    })

    // Will fail without auth or if user doesn't exist
    expect([200, 401, 404]).toContain(response.status())
  })
})

describe('Points System Verification', () => {
  test('leaderboard should show all points categories', async ({ page }) => {
    await page.goto(`${BASE_URL}/leaderboard`)
    await page.waitForTimeout(2000)

    // Verify page loaded
    await expect(page.locator('text=Leaderboard')).toBeVisible()

    // Check for "All Points" header
    await expect(page.locator('text=All Points')).toBeVisible()

    // Look for any user with points breakdown
    const hasPointsBreakdown = 
      await page.locator('text=Invite:').isVisible().catch(() => false) ||
      await page.locator('text=Earned:').isVisible().catch(() => false) ||
      await page.locator('text=Bonus:').isVisible().catch(() => false)

    // At least some users should have points breakdown
    // (might be none if all users have 0 in all categories)
    console.log('Points breakdown visible:', hasPointsBreakdown)
  })
})

// Helper function to wait for element and return if found
async function waitForOptionalElement(page: Page, selector: string, timeout = 5000): Promise<boolean> {
  try {
    await page.waitForSelector(selector, { timeout })
    return true
  } catch {
    return false
  }
}

// Export test suite
export { test }


/**
 * Integration tests for feedback APIs
 */

import { describe, it, expect, beforeAll, afterAll } from 'bun:test'
import { prisma } from '@/lib/database-service'
import {
  CompletionFormat,
  generateGameCompletionFeedback,
  type TradeMetrics,
  type GameMetrics,
} from '@/lib/reputation/reputation-service'

describe('Feedback API Integration', () => {
  let testUserId: string
  let testUserId2: string

  beforeAll(async () => {
    // Create test users
    const user1 = await prisma.user.create({
      data: {
        privyId: `test-feedback-${Date.now()}-1`,
        username: `testuser1-${Date.now()}`,
        displayName: 'Test User 1',
      },
    })

    const user2 = await prisma.user.create({
      data: {
        privyId: `test-feedback-${Date.now()}-2`,
        username: `testuser2-${Date.now()}`,
        displayName: 'Test User 2',
      },
    })

    testUserId = user1.id
    testUserId2 = user2.id
  })

  afterAll(async () => {
    // Cleanup test data
    await prisma.feedback.deleteMany({
      where: {
        OR: [
          { toUserId: testUserId },
          { fromUserId: testUserId },
          { toUserId: testUserId2 },
          { fromUserId: testUserId2 },
        ],
      },
    })

    await prisma.agentPerformanceMetrics.deleteMany({
      where: {
        userId: { in: [testUserId, testUserId2] },
      },
    })

    await prisma.user.deleteMany({
      where: {
        id: { in: [testUserId, testUserId2] },
      },
    })
  })

  describe('CompletionFormat (Trade Feedback)', () => {
    it('should generate feedback for profitable trade', async () => {
      const tradeMetrics: TradeMetrics = {
        profitable: true,
        roi: 0.5, // 50% ROI
        holdingPeriod: 24,
        timingScore: 0.8,
        riskScore: 0.7,
      }

      const feedback = await CompletionFormat(
        testUserId,
        `test_trade_${Date.now()}`,
        tradeMetrics
      )

      expect(feedback).toBeDefined()
      expect(feedback.id).toBeDefined()
      expect(feedback.toUserId).toBe(testUserId)
      expect(feedback.score).toBeGreaterThan(60)
      expect(feedback.comment).toContain('trade')
      expect(feedback.category).toBe('trade_performance')
      expect(feedback.interactionType).toBe('game_to_agent')
      expect(feedback.metadata).toBeDefined()
      expect((feedback.metadata as any).profitable).toBe(true)
      expect((feedback.metadata as any).autoGenerated).toBe(true)
    })

    it('should update feedback metrics after generation', async () => {
      const initialMetrics = await prisma.agentPerformanceMetrics.findUnique({
        where: { userId: testUserId },
      })

      const tradeMetrics: TradeMetrics = {
        profitable: true,
        roi: 0.3,
        holdingPeriod: 12,
        timingScore: 0.7,
        riskScore: 0.6,
      }

      await CompletionFormat(
        testUserId,
        `test_trade_metrics_${Date.now()}`,
        tradeMetrics
      )

      const updatedMetrics = await prisma.agentPerformanceMetrics.findUnique({
        where: { userId: testUserId },
      })

      if (initialMetrics) {
        expect(updatedMetrics?.totalFeedbackCount).toBeGreaterThan(
          initialMetrics.totalFeedbackCount
        )
      } else {
        expect(updatedMetrics?.totalFeedbackCount).toBeGreaterThan(0)
      }
    })

    it('should generate appropriate comments based on score', async () => {
      const excellentMetrics: TradeMetrics = {
        profitable: true,
        roi: 0.8,
        holdingPeriod: 6,
        timingScore: 0.95,
        riskScore: 0.9,
      }

      const excellentFeedback = await CompletionFormat(
        testUserId,
        `excellent_${Date.now()}`,
        excellentMetrics
      )
      expect(excellentFeedback.comment).toContain('Excellent')

      const poorMetrics: TradeMetrics = {
        profitable: false,
        roi: -0.4,
        holdingPeriod: 72,
        timingScore: 0.2,
        riskScore: 0.3,
      }

      const poorFeedback = await CompletionFormat(
        testUserId,
        `poor_${Date.now()}`,
        poorMetrics
      )
      expect(poorFeedback.comment).toContain('Challenging')
    })
  })

  describe('generateGameCompletionFeedback', () => {
    it('should generate feedback for completed game', async () => {
      const gameMetrics: GameMetrics = {
        won: true,
        pnl: 500,
        positionsClosed: 5,
        finalBalance: 1500,
        startingBalance: 1000,
        decisionsCorrect: 8,
        decisionsTotal: 10,
        riskManagement: 0.8,
      }

      const feedback = await generateGameCompletionFeedback(
        testUserId,
        `test_game_${Date.now()}`,
        gameMetrics
      )

      expect(feedback).toBeDefined()
      expect(feedback.id).toBeDefined()
      expect(feedback.toUserId).toBe(testUserId)
      expect(feedback.score).toBeGreaterThanOrEqual(0)
      expect(feedback.score).toBeLessThanOrEqual(100)
      expect(feedback.category).toBe('game_performance')
      expect(feedback.interactionType).toBe('game_to_agent')
      expect((feedback.metadata as any).won).toBe(true)
    })

    it('should update game metrics after generation', async () => {
      const gameMetrics: GameMetrics = {
        won: true,
        pnl: 300,
        positionsClosed: 4,
        finalBalance: 1300,
        startingBalance: 1000,
        decisionsCorrect: 7,
        decisionsTotal: 10,
        riskManagement: 0.7,
      }

      await generateGameCompletionFeedback(
        testUserId,
        `test_game_metrics_${Date.now()}`,
        gameMetrics
      )

      const metrics = await prisma.agentPerformanceMetrics.findUnique({
        where: { userId: testUserId },
      })

      expect(metrics).toBeDefined()
      expect(metrics?.gamesPlayed).toBeGreaterThan(0)
    })
  })
})


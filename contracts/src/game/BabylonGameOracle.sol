// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import "../prediction-markets/PredictionOracle.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title BabylonGameOracle
 * @notice Oracle for Babylon prediction game outcomes
 * @dev Extends PredictionOracle with Babylon-specific features
 * 
 * Babylon Game Integration:
 * - Questions are generated by AI
 * - NPCs and users trade on prediction markets
 * - Questions resolve with predetermined outcomes
 * - Results published on-chain for composability
 * 
 * Security Model:
 * - Commit-reveal prevents front-running
 * - Only authorized game server can publish
 * - TEE attestation provides verifiable compute (optional)
 * - Outcomes are immutable once revealed
 * 
 * External Usage:
 * Any contract can read outcomes via IPredictionOracle:
 *   (bool outcome, bool finalized) = oracle.getOutcome(sessionId);
 * 
 * Example:
 *   // 1. Game server commits at question creation
 *   oracle.commitGame(sessionId, "Will X happen?", commitment);
 *   
 *   // 2. Users trade on Predimarket or custom contracts
 *   
 *   // 3. Game server reveals after resolution
 *   oracle.revealGame(sessionId, outcome, salt, teeQuote);
 *   
 *   // 4. External contracts can now read outcome
 *   predimarket.resolveMarket(sessionId);
 *   bettingContract.claimWinnings(sessionId);
 */
contract BabylonGameOracle is PredictionOracle, Ownable, Pausable {
    
    // ============ State Variables ============
    
    /// @notice Mapping from question ID to session ID for easy lookup
    mapping(string => bytes32) public questionIdToSessionId;
    
    /// @notice Reverse mapping for convenience
    mapping(bytes32 => string) public sessionIdToQuestionId;
    
    /// @notice Track game metadata
    struct GameMetadata {
        string questionId;       // Database question ID
        uint256 questionNumber;  // Sequential question number
        string category;         // Question category
        uint256 createdAt;       // Block timestamp of creation
        address creator;         // Who committed this game
    }
    
    mapping(bytes32 => GameMetadata) public gameMetadata;
    
    /// @notice All session IDs for enumeration
    bytes32[] public allSessionIds;
    
    /// @notice Winners per game (replicate parent storage for accessibility)
    mapping(bytes32 => address[]) private _babylonWinners;
    
    /// @notice Statistics
    uint256 public totalGamesCommitted;
    uint256 public totalGamesRevealed;
    
    // ============ Events ============
    
    event BabylonGameCommitted(
        bytes32 indexed sessionId,
        string questionId,
        uint256 questionNumber,
        string question,
        bytes32 commitment
    );
    
    event BabylonGameRevealed(
        bytes32 indexed sessionId,
        string questionId,
        bool outcome,
        uint256 winnersCount
    );
    
    event GameServerUpdated(address indexed oldServer, address indexed newServer);
    
    // ============ Errors ============
    
    error QuestionAlreadyCommitted(string questionId);
    error SessionNotFound(bytes32 sessionId);
    error InvalidQuestionId();
    
    // ============ Constructor ============
    
    constructor(address _gameServer) PredictionOracle(_gameServer) Ownable(msg.sender) {
        // gameServer is set in parent constructor
    }
    
    // ============ Babylon-Specific Functions ============
    
    /**
     * @notice Commit a Babylon game question
     * @param questionId Database question ID (for tracking)
     * @param questionNumber Sequential question number
     * @param question The yes/no question text
     * @param commitment Hash of (outcome + salt)
     * @param category Question category (optional metadata)
     * @return sessionId Generated session ID
     */
    function commitBabylonGame(
        string calldata questionId,
        uint256 questionNumber,
        string calldata question,
        bytes32 commitment,
        string calldata category
    ) external onlyGameServer whenNotPaused returns (bytes32 sessionId) {
        // Validate inputs
        if (bytes(questionId).length == 0) revert InvalidQuestionId();
        if (questionIdToSessionId[questionId] != bytes32(0)) {
            revert QuestionAlreadyCommitted(questionId);
        }
        
        // Generate deterministic session ID from question ID
        sessionId = keccak256(abi.encodePacked("babylon", questionId, block.timestamp));
        
        // Store mappings
        questionIdToSessionId[questionId] = sessionId;
        sessionIdToQuestionId[sessionId] = questionId;
        
        // Store metadata
        gameMetadata[sessionId] = GameMetadata({
            questionId: questionId,
            questionNumber: questionNumber,
            category: category,
            createdAt: block.timestamp,
            creator: msg.sender
        });
        
        // Track session
        allSessionIds.push(sessionId);
        totalGamesCommitted++;
        
        // Store in parent contract's games mapping
        games[sessionId] = GameOutcome({
            sessionId: sessionId,
            question: question,
            outcome: false,
            commitment: commitment,
            salt: bytes32(0),
            startTime: block.timestamp,
            endTime: 0,
            teeQuote: "",
            totalPayout: 0,
            finalized: false
        });
        
        commitments[commitment] = true;
        gameCount++;
        
        emit BabylonGameCommitted(sessionId, questionId, questionNumber, question, commitment);
        
        return sessionId;
    }
    
    /**
     * @notice Reveal a Babylon game outcome
     * @param sessionId Session ID from commitBabylonGame
     * @param outcome The outcome (true=YES, false=NO)
     * @param salt The salt used in commitment
     * @param teeQuote TEE attestation quote (optional, can be empty)
     * @param winners List of winner addresses (players who predicted correctly)
     * @param totalPayout Total prize pool distributed
     */
    function revealBabylonGame(
        bytes32 sessionId,
        bool outcome,
        bytes32 salt,
        bytes memory teeQuote,
        address[] calldata winners,
        uint256 totalPayout
    ) external onlyGameServer whenNotPaused {
        // Validate session exists
        string memory questionId = sessionIdToQuestionId[sessionId];
        if (bytes(questionId).length == 0) revert SessionNotFound(sessionId);
        
        // Update parent contract's game state
        GameOutcome storage game = games[sessionId];
        require(game.startTime > 0, "Game not found");
        require(!game.finalized, "Already finalized");
        
        // Verify commitment
        bytes32 expectedCommitment = keccak256(abi.encode(outcome, salt));
        require(game.commitment == expectedCommitment, "Commitment mismatch");
        
        // Update game state
        game.outcome = outcome;
        game.salt = salt;
        game.endTime = block.timestamp;
        game.teeQuote = teeQuote;
        _babylonWinners[sessionId] = winners;
        game.totalPayout = totalPayout;
        game.finalized = true;
        
        totalGamesRevealed++;
        
        emit BabylonGameRevealed(sessionId, questionId, outcome, winners.length);
    }
    
    /**
     * @notice Batch commit multiple games (gas optimization)
     * @param questionIds Array of question IDs
     * @param questionNumbers Array of question numbers
     * @param questions Array of question texts
     * @param commitments Array of commitments
     * @param categories Array of categories
     * @return sessionIds Array of generated session IDs
     */
    function batchCommitBabylonGames(
        string[] calldata questionIds,
        uint256[] calldata questionNumbers,
        string[] calldata questions,
        bytes32[] calldata commitments,
        string[] calldata categories
    ) external onlyGameServer whenNotPaused returns (bytes32[] memory sessionIds) {
        uint256 length = questionIds.length;
        require(
            length == questionNumbers.length &&
            length == questions.length &&
            length == commitments.length &&
            length == categories.length,
            "Array length mismatch"
        );
        
        sessionIds = new bytes32[](length);
        
        for (uint256 i = 0; i < length; i++) {
            // Internal commit logic (not external call to preserve msg.sender)
            string calldata questionId = questionIds[i];
            
            // Validate inputs
            if (bytes(questionId).length == 0) revert InvalidQuestionId();
            if (questionIdToSessionId[questionId] != bytes32(0)) {
                revert QuestionAlreadyCommitted(questionId);
            }
            
            // Generate deterministic session ID
            bytes32 _sessionId = keccak256(abi.encodePacked("babylon", questionId, block.timestamp, i));
            
            // Store mappings
            questionIdToSessionId[questionId] = _sessionId;
            sessionIdToQuestionId[_sessionId] = questionId;
            
            // Store metadata
            gameMetadata[_sessionId] = GameMetadata({
                questionId: questionId,
                questionNumber: questionNumbers[i],
                category: categories[i],
                createdAt: block.timestamp,
                creator: msg.sender
            });
            
            // Track session
            allSessionIds.push(_sessionId);
            totalGamesCommitted++;
            
            // Store in parent contract's games mapping
            bytes32 _commitment = commitments[i];
            games[_sessionId] = GameOutcome({
                sessionId: _sessionId,
                question: questions[i],
                outcome: false,
                commitment: _commitment,
                salt: bytes32(0),
                startTime: block.timestamp,
                endTime: 0,
                teeQuote: "",
                totalPayout: 0,
                finalized: false
            });
            
            // Increment game count (parent's public variable)
            gameCount++;
            
            emit BabylonGameCommitted(_sessionId, questionId, questionNumbers[i], questions[i], _commitment);
            
            sessionIds[i] = _sessionId;
        }
        
        return sessionIds;
    }
    
    /**
     * @notice Batch reveal multiple games (gas optimization)
     * @param sessionIds Array of session IDs
     * @param outcomes Array of outcomes
     * @param salts Array of salts
     * @param teeQuotes Array of TEE quotes
     * @param winnersArrays Array of winners arrays
     * @param totalPayouts Array of total payouts
     */
    function batchRevealBabylonGames(
        bytes32[] calldata sessionIds,
        bool[] calldata outcomes,
        bytes32[] calldata salts,
        bytes[] calldata teeQuotes,
        address[][] calldata winnersArrays,
        uint256[] calldata totalPayouts
    ) external onlyGameServer whenNotPaused {
        uint256 length = sessionIds.length;
        require(
            length == outcomes.length &&
            length == salts.length &&
            length == teeQuotes.length &&
            length == winnersArrays.length &&
            length == totalPayouts.length,
            "Array length mismatch"
        );
        
        for (uint256 i = 0; i < length; i++) {
            this.revealBabylonGame(
                sessionIds[i],
                outcomes[i],
                salts[i],
                teeQuotes[i],
                winnersArrays[i],
                totalPayouts[i]
            );
        }
    }
    
    // ============ Query Functions ============
    
    /**
     * @notice Get session ID from question ID
     * @param questionId Database question ID
     * @return sessionId The blockchain session ID
     */
    function getSessionIdByQuestionId(string calldata questionId) external view returns (bytes32) {
        return questionIdToSessionId[questionId];
    }
    
    /**
     * @notice Get question ID from session ID
     * @param sessionId Blockchain session ID
     * @return questionId The database question ID
     */
    function getQuestionIdBySessionId(bytes32 sessionId) external view returns (string memory) {
        return sessionIdToQuestionId[sessionId];
    }
    
    /**
     * @notice Get game metadata
     * @param sessionId Session ID
     * @return metadata Game metadata struct
     */
    function getGameMetadata(bytes32 sessionId) external view returns (GameMetadata memory) {
        return gameMetadata[sessionId];
    }
    
    /**
     * @notice Get all session IDs (for indexing)
     * @return Array of all session IDs
     */
    function getAllSessionIds() external view returns (bytes32[] memory) {
        return allSessionIds;
    }
    
    /**
     * @notice Get session IDs in range (for pagination)
     * @param start Start index
     * @param limit Number of items to return
     * @return Array of session IDs in range
     */
    function getSessionIdsRange(uint256 start, uint256 limit) external view returns (bytes32[] memory) {
        require(start < allSessionIds.length, "Start index out of bounds");
        
        uint256 end = start + limit;
        if (end > allSessionIds.length) {
            end = allSessionIds.length;
        }
        
        bytes32[] memory result = new bytes32[](end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = allSessionIds[i];
        }
        
        return result;
    }
    
    /**
     * @notice Get statistics
     * @return committed Total games committed
     * @return revealed Total games revealed
     * @return pending Games awaiting reveal
     */
    function getStatistics() external view returns (
        uint256 committed,
        uint256 revealed,
        uint256 pending
    ) {
        committed = totalGamesCommitted;
        revealed = totalGamesRevealed;
        pending = totalGamesCommitted - totalGamesRevealed;
    }
    
    /**
     * @notice Get complete game info (convenience function)
     * @param sessionId Session ID
     * @return metadata Game metadata
     * @return game Game outcome data from parent contract
     */
    function getCompleteGameInfo(bytes32 sessionId) external view returns (
        GameMetadata memory metadata,
        GameOutcome memory game
    ) {
        metadata = gameMetadata[sessionId];
        game = games[sessionId];
        return (metadata, game);
    }
    
    // ============ Admin Functions ============
    
    /**
     * @notice Update game server address
     * @param newServer New game server address
     */
    function updateGameServer(address newServer) external onlyOwner {
        require(newServer != address(0), "Invalid address");
        address oldServer = gameServer;
        gameServer = newServer;
        emit GameServerUpdated(oldServer, newServer);
    }
    
    /**
     * @notice Pause the oracle
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @notice Unpause the oracle
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @notice Get winners for a game
     * @param sessionId Session ID
     * @return winners Array of winner addresses
     */
    function getWinners(bytes32 sessionId) external view override returns (address[] memory) {
        return _babylonWinners[sessionId];
    }
    
    /**
     * @notice Get contract version
     */
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
    
    /**
     * @notice Get contract metadata for ERC-8004 discovery
     * @return Contract metadata as JSON string
     */
    function getContractMetadata() external pure returns (string memory) {
        return '{"type":"prediction-oracle","subtype":"babylon-game","name":"Babylon Game Oracle","category":"social-prediction","version":"1.0.0"}';
    }
}


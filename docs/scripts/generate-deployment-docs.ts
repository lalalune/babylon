#!/usr/bin/env tsx
/**
 * Generate deployment documentation from deployments/ folder
 * Creates markdown files with contract addresses and network configurations
 */

import { promises as fs } from 'fs';
import path from 'path';

interface DeploymentInfo {
  network: string;
  chainId: number;
  deployer: string;
  timestamp: string;
  contracts: Record<string, string>;
  gasUsed?: string;
  explorer?: Record<string, string>;
}

async function loadDeployments() {
  const deploymentsDir = path.join(process.cwd(), '../deployments');
  const deployments: DeploymentInfo[] = [];
  
  try {
    const networks = await fs.readdir(deploymentsDir);
    
    for (const network of networks) {
      const networkPath = path.join(deploymentsDir, network);
      const stat = await fs.stat(networkPath);
      
      if (stat.isDirectory()) {
        const latestPath = path.join(networkPath, 'latest.json');
        try {
          const content = await fs.readFile(latestPath, 'utf-8');
          const data = JSON.parse(content);
          deployments.push({
            network: data.network || network,
            ...data,
          });
        } catch {
          console.warn(`  ‚ö† Could not read ${latestPath}`);
        }
      }
    }
  } catch (error) {
    console.error('Error reading deployments:', error);
  }
  
  return deployments;
}

function generateMarkdown(deployments: DeploymentInfo[]): string {
  let md = `# Deployment Addresses\n\n`;
  md += `Contract addresses for all deployed networks.\n\n`;
  md += `> **Auto-generated**: This file is automatically generated from the \`deployments/\` folder. Do not edit manually.\n\n`;
  
  if (deployments.length === 0) {
    md += `No deployments found.\n\n`;
    return md;
  }
  
  for (const deployment of deployments) {
    md += `## ${deployment.network}\n\n`;
    md += `- **Chain ID**: ${deployment.chainId}\n`;
    md += `- **Deployer**: \`${deployment.deployer}\`\n`;
    md += `- **Deployed**: ${new Date(deployment.timestamp).toLocaleString()}\n`;
    if (deployment.gasUsed) {
      md += `- **Gas Used**: ${deployment.gasUsed}\n`;
    }
    md += `\n`;
    
    // Contracts table
    md += `### Contracts\n\n`;
    md += `| Contract | Address | Explorer |\n`;
    md += `|----------|---------|----------|\n`;
    
    for (const [name, address] of Object.entries(deployment.contracts)) {
      const explorerUrl = deployment.explorer?.[name] || '#';
      md += `| ${name} | \`${address}\` | [View ‚Üí](${explorerUrl}) |\n`;
    }
    
    md += `\n`;
    
    // Copy-paste section
    md += `### Environment Variables\n\n`;
    md += `Add these to your \`.env.local\`:\n\n`;
    md += `\`\`\`bash\n`;
    for (const [name, address] of Object.entries(deployment.contracts)) {
      const envName = name.toUpperCase().replace(/([A-Z])/g, '_$1').replace(/^_/, '');
      md += `${envName}_ADDRESS="${address}"\n`;
    }
    md += `\`\`\`\n\n`;
    
    md += `---\n\n`;
  }
  
  // Add integration guide
  md += `## Integration Guide\n\n`;
  md += `### TypeScript\n\n`;
  md += `\`\`\`typescript\n`;
  md += `import { ethers } from 'ethers';\n\n`;
  md += `const provider = new ethers.JsonRpcProvider(RPC_URL);\n`;
  md += `const contract = new ethers.Contract(\n`;
  md += `  '0x...',  // Contract address\n`;
  md += `  ABI,      // Contract ABI\n`;
  md += `  provider\n`;
  md += `);\n\n`;
  md += `// Call contract method\n`;
  md += `const result = await contract.methodName(args);\n`;
  md += `\`\`\`\n\n`;
  
  md += `### Contract ABIs\n\n`;
  md += `Contract ABIs are available in the [\`contracts/\` directory](https://github.com/elizaos/babylon/tree/main/contracts) or can be fetched from the block explorer.\n\n`;
  
  return md;
}

function generateContractReference(deployments: DeploymentInfo[]): string {
  let md = `# Contract Reference\n\n`;
  md += `Quick reference for all deployed contracts.\n\n`;
  
  // Extract unique contracts across all networks
  const contractNames = new Set<string>();
  for (const deployment of deployments) {
    Object.keys(deployment.contracts).forEach(name => contractNames.add(name));
  }
  
  for (const contractName of Array.from(contractNames).sort()) {
    md += `## ${contractName}\n\n`;
    
    md += `### Deployments\n\n`;
    md += `| Network | Address | Explorer |\n`;
    md += `|---------|---------|----------|\n`;
    
    for (const deployment of deployments) {
      const address = deployment.contracts[contractName];
      if (address) {
        const explorerUrl = deployment.explorer?.[contractName] || '#';
        md += `| ${deployment.network} | \`${address}\` | [View ‚Üí](${explorerUrl}) |\n`;
      }
    }
    
    md += `\n`;
  }
  
  return md;
}

async function main() {
  console.log('üîç Loading deployment information...\n');
  
  const deployments = await loadDeployments();
  
  if (deployments.length === 0) {
    console.log('‚ö† No deployments found in ../deployments/');
    return;
  }
  
  console.log(`üìù Found ${deployments.length} deployment(s):\n`);
  for (const d of deployments) {
    console.log(`  ‚úì ${d.network} (Chain ID: ${d.chainId})`);
    console.log(`    Contracts: ${Object.keys(d.contracts).length}`);
  }
  
  console.log('\nüìÑ Generating documentation...\n');
  
  // Generate main deployment docs
  const mainDocs = generateMarkdown(deployments);
  const mainPath = path.join(process.cwd(), 'app/deployments/_generated/addresses.mdx');
  await fs.mkdir(path.dirname(mainPath), { recursive: true });
  await fs.writeFile(mainPath, mainDocs);
  console.log('  ‚úì Saved deployment addresses');
  
  // Generate contract reference
  const refDocs = generateContractReference(deployments);
  const refPath = path.join(process.cwd(), 'app/contracts/_generated/deployed-contracts.mdx');
  await fs.mkdir(path.dirname(refPath), { recursive: true });
  await fs.writeFile(refPath, refDocs);
  console.log('  ‚úì Saved contract reference');
  
  // Save raw JSON for programmatic access
  const jsonPath = path.join(process.cwd(), 'public/deployments.json');
  await fs.writeFile(jsonPath, JSON.stringify(deployments, null, 2));
  console.log('  ‚úì Saved JSON export');
  
  console.log('\n‚úÖ Deployment documentation generated successfully!');
}

main().catch(console.error);


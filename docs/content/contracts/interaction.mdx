# Interacting with Contracts

Complete guide to interacting with Babylon's smart contracts.

## Setup

### Install Dependencies

```bash
bun add ethers@^6.15.0
```

### Initialize Provider and Contract

```typescript
import { ethers } from 'ethers';
import IdentityRegistryABI from './abis/IdentityRegistry.json';
import ReputationSystemABI from './abis/ReputationSystem.json';

// Setup provider
const provider = new ethers.JsonRpcProvider(
 'https://sepolia.base.org'
);

// Setup wallet
const wallet = new ethers.Wallet(
 process.env.PRIVATE_KEY!,
 provider
);

// Initialize contracts
const identityRegistry = new ethers.Contract(
 '0x4102F9b209796b53a18B063A438D05C7C9Af31A2', // Base Sepolia
 IdentityRegistryABI,
 wallet
);

const reputationSystem = new ethers.Contract(
 '0x7960E6044bbeE480F5388be1903b3A1dd69c126D',
 ReputationSystemABI,
 wallet
);
```

## ERC-8004 Identity Registry

### Register Agent

```typescript
async function registerAgent(
 name: string,
 endpoint: string,
 capabilities: string[],
 metadataCID: string
) {
 // Calculate capabilities hash
 const capabilitiesHash = ethers.id(
 JSON.stringify(capabilities)
 );
 
 // Register
 const tx = await identityRegistry.registerAgent(
 name,
 endpoint,
 capabilitiesHash,
 `ipfs://${metadataCID}`
 );
 
 console.log('Transaction sent:', tx.hash);
 
 // Wait for confirmation
 const receipt = await tx.wait();
 console.log('Confirmed in block:', receipt.blockNumber);
 
 // Get token ID
 const tokenId = await identityRegistry.addressToTokenId(
 wallet.address
 );
 
 console.log('Agent Token ID:', tokenId.toString());
 
 return {
 tokenId: tokenId.toString(),
 txHash: receipt.hash,
 blockNumber: receipt.blockNumber,
 gasUsed: receipt.gasUsed.toString()
 };
}

// Usage
await registerAgent(
 'AlphaTrader',
 'wss://agent.example.com/a2a',
 ['trading', 'analysis'],
 'QmX1Yn5tPV1yDyCAh8AV2...'
);
```

### Read Agent Profile

```typescript
async function getAgentProfile(address: string) {
 // Get token ID
 const tokenId = await identityRegistry.addressToTokenId(address);
 
 if (tokenId === 0n) {
 throw new Error('Agent not registered');
 }
 
 // Get profile
 const profile = await identityRegistry.profiles(tokenId);
 
 return {
 tokenId: tokenId.toString(),
 name: profile.name,
 endpoint: profile.endpoint,
 registeredAt: new Date(Number(profile.registeredAt) * 1000),
 isActive: profile.isActive,
 metadata: profile.metadata
 };
}

// Usage
const profile = await getAgentProfile('0x742d35...');
console.log('Agent:', profile.name);
console.log('Endpoint:', profile.endpoint);
console.log('Registered:', profile.registeredAt);
```

### Update Agent

```typescript
async function updateAgent(
 newEndpoint: string,
 newCapabilities: string[],
 newMetadataCID: string
) {
 const capabilitiesHash = ethers.id(
 JSON.stringify(newCapabilities)
 );
 
 const tx = await identityRegistry.updateAgent(
 newEndpoint,
 capabilitiesHash,
 `ipfs://${newMetadataCID}`
 );
 
 await tx.wait();
 console.log('Agent updated');
}
```

### Listen for Events

```typescript
// Listen for new registrations
identityRegistry.on('AgentRegistered', (tokenId, owner, name, endpoint) => {
 console.log('New agent registered:');
 console.log(' Token ID:', tokenId.toString());
 console.log(' Owner:', owner);
 console.log(' Name:', name);
 console.log(' Endpoint:', endpoint);
});

// Listen for updates
identityRegistry.on('AgentUpdated', (tokenId, endpoint, capabilitiesHash) => {
 console.log(`Agent ${tokenId} updated`);
});

// Query past events
const filter = identityRegistry.filters.AgentRegistered();
const events = await identityRegistry.queryFilter(filter, -1000); // Last 1000 blocks

for (const event of events) {
 console.log('Past registration:', event.args);
}
```

## Reputation System

### Record Feedback

```typescript
async function recordFeedback(
 agentTokenId: number,
 score: number,
 category: string
) {
 const tx = await reputationSystem.recordFeedback(
 agentTokenId,
 score, // 0-100
 category, // 'trading', 'interaction', 'analysis'
 '' // Optional comment
 );
 
 await tx.wait();
 console.log('Feedback recorded');
}

// Usage
await recordFeedback(42, 85, 'trading');
```

### Get Reputation

```typescript
async function getReputation(tokenId: number) {
 const metrics = await reputationSystem.getReputation(tokenId);
 
 return {
 totalInteractions: metrics.totalInteractions.toString(),
 successfulInteractions: metrics.successfulInteractions.toString(),
 aggregateScore: metrics.aggregateScore.toString(),
 trustScore: Number(metrics.aggregateScore) / Number(metrics.totalInteractions),
 lastUpdated: new Date(Number(metrics.lastUpdated) * 1000)
 };
}

// Usage
const rep = await getReputation(42);
console.log('Trust Score:', rep.trustScore);
console.log('Total Interactions:', rep.totalInteractions);
```

## Diamond Proxy Pattern

### Call Facet Functions

```typescript
import DiamondABI from './abis/Diamond.json';
import PredictionMarketFacetABI from './abis/PredictionMarketFacet.json';

// Diamond proxy address
const diamond = new ethers.Contract(
 '0xdC3f0aD2f76Cea9379af897fa8EAD4A6d5e43990',
 DiamondABI,
 wallet
);

// Call facet function through diamond
const predictionMarket = new ethers.Contract(
 diamond.target, // Same address as diamond
 PredictionMarketFacetABI,
 wallet
);

// Create market
const tx = await predictionMarket.createMarket(
 'Will Bitcoin reach $100k?',
 ethers.parseEther('100'), // Initial liquidity
 Math.floor(Date.now() / 1000) + 86400 // 24 hours from now
);

await tx.wait();
```

### Query Diamond Facets

```typescript
import DiamondLoupeFacetABI from './abis/DiamondLoupeFacet.json';

const loupe = new ethers.Contract(
 diamond.target,
 DiamondLoupeFacetABI,
 provider
);

// Get all facets
const facets = await loupe.facets();

for (const facet of facets) {
 console.log('Facet:', facet.facetAddress);
 console.log('Functions:', facet.functionSelectors.length);
}

// Get facet address for function
const selector = ethers.id('createMarket(string,uint256,uint256)').slice(0, 10);
const facetAddress = await loupe.facetAddress(selector);
console.log('createMarket is in facet:', facetAddress);
```

## Gas Optimization

### Estimate Gas Before Sending

```typescript
// Estimate gas
const gasEstimate = await identityRegistry.registerAgent.estimateGas(
 'AgentName',
 'wss://endpoint.com',
 capabilitiesHash,
 metadataCID
);

console.log('Estimated gas:', gasEstimate.toString());

// Send with buffer (10% extra)
const gasLimit = gasEstimate * 110n / 100n;

const tx = await identityRegistry.registerAgent(
 'AgentName',
 'wss://endpoint.com',
 capabilitiesHash,
 metadataCID,
 { gasLimit }
);
```

### Check Gas Price

```typescript
// Get current gas price
const feeData = await provider.getFeeData();

console.log('Max fee per gas:', ethers.formatUnits(feeData.maxFeePerGas!, 'gwei'), 'gwei');
console.log('Priority fee:', ethers.formatUnits(feeData.maxPriorityFeePerGas!, 'gwei'), 'gwei');

// Send with custom gas price
const tx = await contract.someFunction(args, {
 maxFeePerGas: ethers.parseUnits('2', 'gwei'),
 maxPriorityFeePerGas: ethers.parseUnits('1', 'gwei')
});
```

## Error Handling

### Handle Reverts

```typescript
try {
 const tx = await identityRegistry.registerAgent(...);
 await tx.wait();
} catch (error: any) {
 if (error.code === 'ACTION_REJECTED') {
 console.log('User rejected transaction');
 } else if (error.reason) {
 // Contract revert reason
 console.log('Contract reverted:', error.reason);
 
 if (error.reason.includes('Already registered')) {
 console.log('This wallet already has an agent');
 }
 } else {
 console.error('Transaction failed:', error);
 }
}
```

### Parse Events from Receipt

```typescript
const tx = await identityRegistry.registerAgent(...);
const receipt = await tx.wait();

// Parse events
for (const log of receipt.logs) {
 try {
 const parsed = identityRegistry.interface.parseLog({
 topics: log.topics,
 data: log.data
 });
 
 if (parsed?.name === 'AgentRegistered') {
 console.log('Agent registered:', {
 tokenId: parsed.args.tokenId.toString(),
 owner: parsed.args.owner,
 name: parsed.args.name
 });
 }
 } catch (error) {
 // Not from this contract
 }
}
```

## Batch Operations

### Read Multiple Values

```typescript
// Use multicall for batch reads
const calls = [
 identityRegistry.addressToTokenId(address1),
 identityRegistry.addressToTokenId(address2),
 identityRegistry.addressToTokenId(address3)
];

const results = await Promise.all(calls);

for (let i = 0; i < results.length; i++) {
 console.log(`Address ${i+1} token ID:`, results[i].toString());
}
```

## Testing Contracts

### Using Hardhat/Foundry

```typescript
// Mock contract for testing
import { MockERC8004 } from '@babylon/test-utils';

describe('Agent Registration', () => {
 let registry: MockERC8004;
 let wallet: ethers.Wallet;
 
 beforeEach(async () => {
 // Deploy mock contract
 registry = await MockERC8004.deploy();
 wallet = ethers.Wallet.createRandom();
 });
 
 it('should register agent', async () => {
 const tx = await registry.connect(wallet).registerAgent(
 'TestAgent',
 'wss://test.com',
 ethers.id('["trading"]'),
 'ipfs://test'
 );
 
 await tx.wait();
 
 const tokenId = await registry.addressToTokenId(wallet.address);
 expect(tokenId).toBeGreaterThan(0);
 });
});
```

## Next Steps

- [ERC-8004 Identity](/contracts/erc8004-identity)
- [Contract Overview](/contracts/overview)
- [Deploy to Vercel](/deployment/vercel)

